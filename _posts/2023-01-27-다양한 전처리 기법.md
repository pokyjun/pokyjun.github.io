---
layout : single
title: "다양한 전처리 기법"
categories : "Python", "Pandas"
tag : [python, Pandas, Outlier, Normalization, Standardization, Missing Data, One-Hot Encoding, Binning]
author_profile: false
sidebar:
  nav: "docs"
---

# 다양한 전처리 기법

# 전처리
### 전처리의 중요성
***
"데이터 분석의 8할은 데이터 전처리이다"라는 말이 있습니다. 데이터 분석에 있어 전처리가 왜 중요할까요?

전처리에 따라서 데이터 분석의 질이 달라지기 때문입니다.  
전치가 충분히 되어있지 않거나 잘못된 데이터를 사용한 경우 분석 결과의 신뢰도가 떨어지고, 예측 모델의 정확도도 떨어질 것입니다. 

> 사용할 데이터는 [관세청 수출입 무역 통계](https://unipass.customs.go.kr/ets/index.do)에서 가공한 데이터입니다.   
파일명 : trade.csv

# 학습 목표
***
- 중복된 데이터를 찾아 제거할 수 있고, 결측치(missing data)를 제거하거나 채워 넣을 수 있다.
- 데이터를 정규화시킬 수 있다.
- 이상치(outlier)를 찾고, 이를 처리할 수 있다.
- 범주형 데이터를 원-핫 인코딩할 수 있다.
- 연속적인 데이터를 구간으로 나눠 범주형 데이터로 변환할 수 있다.

# 학습 목차
***
1. 결측치(Missing Data)
2. 중복된 데이터
3. 이상치(Outlier)
4. 정규화(Normalization)
5. 원-핫 인코딩(One-Hot Encoding)
6. 구간화(Binning)

# 자 그럼 이제 시작하겠습니다!

# 필요 라이브러리 + 데이터


```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

trade = pd.read_csv('trade.csv')
trade.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
      <th>기타사항</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015년 01월</td>
      <td>중국</td>
      <td>116932.0</td>
      <td>12083947.0</td>
      <td>334522.0</td>
      <td>8143271.0</td>
      <td>3940676.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015년 01월</td>
      <td>미국</td>
      <td>65888.0</td>
      <td>5561545.0</td>
      <td>509564.0</td>
      <td>3625062.0</td>
      <td>1936484.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015년 01월</td>
      <td>일본</td>
      <td>54017.0</td>
      <td>2251307.0</td>
      <td>82480.0</td>
      <td>3827247.0</td>
      <td>-1575940.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015년 02월</td>
      <td>중국</td>
      <td>86228.0</td>
      <td>9927642.0</td>
      <td>209100.0</td>
      <td>6980874.0</td>
      <td>2946768.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015년 02월</td>
      <td>미국</td>
      <td>60225.0</td>
      <td>5021264.0</td>
      <td>428678.0</td>
      <td>2998216.0</td>
      <td>2023048.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



# 결측치 확인


```python
print('전체 데이터 건수:', len(trade))
```

    전체 데이터 건수: 199



```python
trade.isnull().sum()
```




    기간        0
    국가명       0
    수출건수      3
    수출금액      4
    수입건수      3
    수입금액      3
    무역수지      4
    기타사항    199
    dtype: int64



'기타사항'을 보면 전부 결측치라는 것을 알 수 있습니다.  
아무런 정보가 없는 컬럼이기에 삭제하도록 합시다.


```python
trade = trade.drop('기타사항',axis=1)
trade.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015년 01월</td>
      <td>중국</td>
      <td>116932.0</td>
      <td>12083947.0</td>
      <td>334522.0</td>
      <td>8143271.0</td>
      <td>3940676.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015년 01월</td>
      <td>미국</td>
      <td>65888.0</td>
      <td>5561545.0</td>
      <td>509564.0</td>
      <td>3625062.0</td>
      <td>1936484.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015년 01월</td>
      <td>일본</td>
      <td>54017.0</td>
      <td>2251307.0</td>
      <td>82480.0</td>
      <td>3827247.0</td>
      <td>-1575940.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015년 02월</td>
      <td>중국</td>
      <td>86228.0</td>
      <td>9927642.0</td>
      <td>209100.0</td>
      <td>6980874.0</td>
      <td>2946768.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015년 02월</td>
      <td>미국</td>
      <td>60225.0</td>
      <td>5021264.0</td>
      <td>428678.0</td>
      <td>2998216.0</td>
      <td>2023048.0</td>
    </tr>
  </tbody>
</table>
</div>



'기타사항'이 삭제된 것을 확인할 수 있습니다.  
이제 결측치가 있는 행을 살펴봅시다!

any(axis=1)은 각 행의 열마다 결측치가 하나라도 있으면 그 행을 뽑아줍니다


```python
print(trade.isnull().any(axis=1))
print(type(trade.isnull().any(axis=1)))
```

    0      False
    1      False
    2      False
    3      False
    4      False
           ...  
    194    False
    195    False
    196     True
    197     True
    198     True
    Length: 199, dtype: bool
    <class 'pandas.core.series.Series'>


trade.isnull().any(axis=1) 그냥 출력하면 Series로 나옵니다.   
이런식으로는 결측치가 어디있는지 못 찾습니다. 

trade.isnull().any(axis=1)을 다시 DataFrame에 넣어주면 DataFrame으로 나옵니다.


```python
print(type(trade[trade.isnull().any(axis=1)]))
```

    <class 'pandas.core.frame.DataFrame'>



```python
trade[trade.isnull().any(axis=1)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>191</th>
      <td>2020년 04월</td>
      <td>미국</td>
      <td>105360.0</td>
      <td>NaN</td>
      <td>1141118.0</td>
      <td>5038739.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>196</th>
      <td>2020년 06월</td>
      <td>중국</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>197</th>
      <td>2020년 06월</td>
      <td>미국</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>198</th>
      <td>2020년 06월</td>
      <td>일본</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



Index 191 데이터는 수출금액과 무역수지 컬럼만 결측치이고, Index 196,197,198은 기간, 국가명을 제외하고 모두 결측치입니다.   
이 경우 Index 191 데이터는 삭제하기보다 특정 값으로 대체하는 것이 좋습니다.   
반면 Index 196,197,198은 제거하는 것이 바람직합니다.

우선 196,197,198을 제거하겠습니다.

DataFrame의 'dropna'는 결측치를 삭제해 주는 메서드입니다.  
- subset 옵션으로 특정 컬럼을 선택하겠습니다.   
- how 옵션으로 선택한 컬럼(subset) 전부가 결측치인 행을 삭제하겠다는 의미로 'all'을 사용하겠습니다. (any:하나라도 결측치인 경우)
- inplace 옵션으로 해당 DataFrame 내부에 바로 적용시키겠습니다.


```python
# 삭제
trade.dropna(how='all', subset=['수출건수','수출금액','수입건수','수입금액','무역수지'],inplace=True)
```


```python
# 확인
trade[trade.isnull().any(axis=1)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>191</th>
      <td>2020년 04월</td>
      <td>미국</td>
      <td>105360.0</td>
      <td>NaN</td>
      <td>1141118.0</td>
      <td>5038739.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



삭제가 아주 잘 되었네요!

index 191과 같이 수치형 데이터를 보완할 방법은 많습니다.    
1. 특정 값을 지정해 줄 수 있습니다. 그러나 결측치가 많은 경우, 모두 같은 값으로 대체한다면 데이터의 분산이 실제보다 작아지는 문제가 생길 수 있습니다.
2. 평균, 중앙값 등으로 대체할 수 있습니다. 1번에서 특정 값으로 대체했을 때와 마찬가지로 결측치가 많은 경우 데이터의 분산이 실제보다 작아지는 문제가 발생할 수 있습니다.
3. 다른 데이터를 이용해 예측값으로 대체할 수 있습니다. 예를 들어 머신러닝 모델로 2020년 4월 미국의 예측값을 만들고, 이 값으로 결측치를 보완할 수 있습니다.
4. 시계열 특성을 가진 데이터의 경우 앞,뒤 데이터를 통해 결측치를 대체할 수 있습니다. 예를 들어 기온을 측정하는 센서 데이터에서 결측치가 발생할 경우, 전후 데이터의 평균으로 보완할 수 있습니다.

여기서는 4번 방법을 통해 보완하도록 하겠습니다.

미국 - 2020년 4월 이니 미국 - 2020년 3,5월의 데이터를 출력하겠습니다.


```python
trade[(trade['국가명'] == '미국') & (trade['기간'] == '2020년 03월')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>188</th>
      <td>2020년 03월</td>
      <td>미국</td>
      <td>97117.0</td>
      <td>7292838.0</td>
      <td>1368345.0</td>
      <td>5388338.0</td>
      <td>1904500.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
trade[(trade['국가명'] == '미국') & (trade['기간'] == '2020년 05월')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>194</th>
      <td>2020년 05월</td>
      <td>미국</td>
      <td>126598.0</td>
      <td>4600726.0</td>
      <td>1157163.0</td>
      <td>4286873.0</td>
      <td>313853.0</td>
    </tr>
  </tbody>
</table>
</div>



3월 인덱스 - 188 / 4월 인덱스 - 191 / 5월 인덱스 - 194

loc는 그 위치에 있는 행을 뽑아줍니다.


```python
trade.loc[[188,191,194]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>188</th>
      <td>2020년 03월</td>
      <td>미국</td>
      <td>97117.0</td>
      <td>7292838.0</td>
      <td>1368345.0</td>
      <td>5388338.0</td>
      <td>1904500.0</td>
    </tr>
    <tr>
      <th>191</th>
      <td>2020년 04월</td>
      <td>미국</td>
      <td>105360.0</td>
      <td>NaN</td>
      <td>1141118.0</td>
      <td>5038739.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>194</th>
      <td>2020년 05월</td>
      <td>미국</td>
      <td>126598.0</td>
      <td>4600726.0</td>
      <td>1157163.0</td>
      <td>4286873.0</td>
      <td>313853.0</td>
    </tr>
  </tbody>
</table>
</div>



수출금액 컬럼값을 이전 달과 다음 달의 평균으로 채우도록 합시다.


```python
trade.loc[191, '수출금액'] = (trade.loc[188, '수출금액'] + trade.loc[194, '수출금액']) / 2
trade.loc[[191]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>191</th>
      <td>2020년 04월</td>
      <td>미국</td>
      <td>105360.0</td>
      <td>5946782.0</td>
      <td>1141118.0</td>
      <td>5038739.0</td>
      <td>4554462.0</td>
    </tr>
  </tbody>
</table>
</div>



index 191의 무역수지 값은 수출금액 - 수입금액으로 채우도록 하겠습니다.


```python
trade.loc[191, '무역수지'] = trade.loc[191, '수출금액'] - trade.loc[191, '수입금액']
trade.loc[[191]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>191</th>
      <td>2020년 04월</td>
      <td>미국</td>
      <td>105360.0</td>
      <td>5946782.0</td>
      <td>1141118.0</td>
      <td>5038739.0</td>
      <td>908043.0</td>
    </tr>
  </tbody>
</table>
</div>



지금까지 데이터가 수치형인 경우 결측치를 삭제하거나 대체하는 방법에 실습해 보았습니다. 데이터가 범주형인 경우는 어떻게 해야 할까요? 이는 수치형일 때와 유사합니다!!
> - 수치형 데이터 : 관측값이 수치로 측정되는 자료
    - ex) : 키, 몸무게 
> - 범주형 데이터 : 관측 결과가 몇 개의 범주 또는 항목으로 나타나는 자료
    - ex) : 성별(남,여), 혈액형(A,B,O,AB)

# 중복된 데이터

데이터를 수집하는 과정에서 중복된 데이터가 생길 수 있습니다. 같은 값을 가진 데이터 없이 행(row)별로 값이 유일해야 한다면 중복값을 제거해야 합니다.

- DataFrame.duplicated()는 중복된 데이터 여부를 불리언 값으로 반환해 줍니다.


```python
trade.duplicated()
```




    0      False
    1      False
    2      False
    3      False
    4      False
           ...  
    191    False
    192    False
    193    False
    194    False
    195    False
    Length: 196, dtype: bool



위의 타입은 Series입니다.   
저는 Series보다 DataFrame을 좋아합니다.  
-> 아래처럼 한 번 더 감싸주시면 됩니다!!


```python
trade[trade.duplicated()]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>187</th>
      <td>2020년 03월</td>
      <td>중국</td>
      <td>248059.0</td>
      <td>10658599.0</td>
      <td>358234.0</td>
      <td>8948918.0</td>
      <td>1709682.0</td>
    </tr>
  </tbody>
</table>
</div>



중국의 2020년 3월의 데이터가 중복되는군요!


```python
trade[(trade['기간'] == '2020년 03월') & (trade['국가명'] == '중국')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>186</th>
      <td>2020년 03월</td>
      <td>중국</td>
      <td>248059.0</td>
      <td>10658599.0</td>
      <td>358234.0</td>
      <td>8948918.0</td>
      <td>1709682.0</td>
    </tr>
    <tr>
      <th>187</th>
      <td>2020년 03월</td>
      <td>중국</td>
      <td>248059.0</td>
      <td>10658599.0</td>
      <td>358234.0</td>
      <td>8948918.0</td>
      <td>1709682.0</td>
    </tr>
  </tbody>
</table>
</div>



186, 187이 중복되어 있습니다.  
pandas에서는 DataFrame.drop_duplicates를 통해 중복값을 손쉽게 삭제할 수 있습니다!


```python
trade.drop_duplicates(inplace=True)
trade[(trade['기간'] == '2020년 03월') & (trade['국가명'] == '중국')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>186</th>
      <td>2020년 03월</td>
      <td>중국</td>
      <td>248059.0</td>
      <td>10658599.0</td>
      <td>358234.0</td>
      <td>8948918.0</td>
      <td>1709682.0</td>
    </tr>
  </tbody>
</table>
</div>



DataFrame.drop_duplicates를 좀 더 자세히 살펴보겠습니다.


```python
df = pd.DataFrame({'id':['001', '002', '003', '004', '002'], 
                   'name':['Park Yun', 'Kim Sung', 'Park Jin', 'Lee Han', 'Kim Min']})
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>001</td>
      <td>Park Yun</td>
    </tr>
    <tr>
      <th>1</th>
      <td>002</td>
      <td>Kim Sung</td>
    </tr>
    <tr>
      <th>2</th>
      <td>003</td>
      <td>Park Jin</td>
    </tr>
    <tr>
      <th>3</th>
      <td>004</td>
      <td>Lee Han</td>
    </tr>
    <tr>
      <th>4</th>
      <td>002</td>
      <td>Kim Min</td>
    </tr>
  </tbody>
</table>
</div>



id가 002인 데이터가 2개 있습니다. id가 사람마다 unique 하다고 할 때, 둘 중 하나는 삭제해야 합니다.

index가 클수록 나중에 들어온 데이터이고, 사용자가 이름을 수정했을 때 업데이트가 되지 않고 삽입이 되어 생긴 문제라고 가정합니다. 즉, id가 중복된 경우 맨 나중에 들어온 값만 남겨야 합니다.

DataFrame.drop_duplicates의 subset, keep 옵션을 통해 손쉽게 중복을 제거할 수 있습니다.

- [DataFrame.drop_duplicates](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html)


```python
df.drop_duplicates(subset=['id'], keep='last')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>001</td>
      <td>Park Yun</td>
    </tr>
    <tr>
      <th>2</th>
      <td>003</td>
      <td>Park Jin</td>
    </tr>
    <tr>
      <th>3</th>
      <td>004</td>
      <td>Lee Han</td>
    </tr>
    <tr>
      <th>4</th>
      <td>002</td>
      <td>Kim Min</td>
    </tr>
  </tbody>
</table>
</div>



# 이상치

이상치란 대부분 값의 범위에서 극단적으로 크거나 작은 값을 의미합니다.

Min-Max Scaling(정규화 - 값의 범위를 0~1) 해보면 대부분의 값은 0에 가깝고 이상치만 1에 가까운 값을 가지게 될 것입니다. 이렇게 몇 개의 이상치 때문에 대부분 값의 차이는 의미가 거의 없어지게 됩니다. 극단적인 값이 생기는 경우를 제외하고 데이터를 고려하고 싶은 경우 이상치를 제거하고 분석합니다.

그렇다면 이상치를 어떻게 찾아내야 할까요? 현실에서 이상치를 찾는 것(anomaly detection) 자체가 큰 분야입니다.

가장 먼저 생각해 볼 수 있는 간단하고 자주 사용되는 방법은 **평균과 표준편차를 이용하는 z-score** 방법입니다.

평균을 빼주고 표준편차로 나눠 z-score를 계산합니다. 그리고 z-score가 특정 기준을 넘어서는 데이터에 대해 이상치라고 판단합니다! 
- 기준을 작게하면 이상치라고 판단되는 데이터가 많아지고, 기준을 크게하면 이상치라고 판단되는 데이터가 작아집니다.

이상치를 판단한 뒤 어떻게 해야 할까요?
1. 가장 간단한 방법으로 이상치를 삭제할 수 있습니다. 이상치를 원래 데이터에서 삭제하고, 이상치끼리 따로 분석하는 방안도 있습니다.
2. 이상치를 다른 값으로 대체할 수 있습니다. 데이터가 적으면 이상치를 삭제하기보다 다른 값으로 대체하는 것이 나을 수 있습니다. 예를 들어 최댓값, 최솟값을 설정해 데이터의 범위를 제한할 수 있습니다.
3. 결측치와 마찬가지로 다른 데이터를 활용하여 예측 모델을 만들어 예측값을 활용할 수도 있습니다.
4. binning을 통해 수치형 데이터를 범주형으로 바꿀 수도 있습니다.


### z-score method
***
이제 우리 데이터를 처리해 봅시다. 이상치인 데이터의 인덱스를 리턴하는 outlier라는 함수를 만들었습니다. 데이터프레임 df, 컬럼 col, 기준 z를 인풋으로 받습니다. 
- abs(df[col] - np.mean(df[col])) : 데이터에서 평균을 빼준 것에 절대값을 취합니다.
- abs(df[col] - np.mean(df[col]))/np.std(df[col]) : 위에 한 작업에 표준편차로 나눠줍니다.
- df[abs(df[col] - np.mean(df[col]))/np.std(df[col])>z].index: 값이 z보다 큰 데이터의 인덱스를 추출합니다.


```python
def outlier(df, col, z):
    return df[abs(df[col] - np.mean(df[col]))/np.std(df[col])>z].index
```


```python
trade.loc[outlier(trade, '무역수지', 1.5)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>2015년 03월</td>
      <td>중국</td>
      <td>117529.0</td>
      <td>11868032.0</td>
      <td>234321.0</td>
      <td>7226911.0</td>
      <td>4641121.0</td>
    </tr>
    <tr>
      <th>75</th>
      <td>2017년 02월</td>
      <td>중국</td>
      <td>159062.0</td>
      <td>11118131.0</td>
      <td>188555.0</td>
      <td>6600637.0</td>
      <td>4517495.0</td>
    </tr>
    <tr>
      <th>80</th>
      <td>2017년 03월</td>
      <td>일본</td>
      <td>65093.0</td>
      <td>2395932.0</td>
      <td>165734.0</td>
      <td>5157589.0</td>
      <td>-2761657.0</td>
    </tr>
    <tr>
      <th>96</th>
      <td>2017년 09월</td>
      <td>중국</td>
      <td>183442.0</td>
      <td>13540683.0</td>
      <td>295443.0</td>
      <td>8443414.0</td>
      <td>5097269.0</td>
    </tr>
    <tr>
      <th>99</th>
      <td>2017년 10월</td>
      <td>중국</td>
      <td>137873.0</td>
      <td>12580474.0</td>
      <td>244977.0</td>
      <td>7932403.0</td>
      <td>4648071.0</td>
    </tr>
    <tr>
      <th>101</th>
      <td>2017년 10월</td>
      <td>일본</td>
      <td>63510.0</td>
      <td>1847999.0</td>
      <td>127696.0</td>
      <td>4418583.0</td>
      <td>-2570584.0</td>
    </tr>
    <tr>
      <th>102</th>
      <td>2017년 11월</td>
      <td>중국</td>
      <td>421194.0</td>
      <td>14000887.0</td>
      <td>307790.0</td>
      <td>9253318.0</td>
      <td>4747569.0</td>
    </tr>
    <tr>
      <th>105</th>
      <td>2017년 12월</td>
      <td>중국</td>
      <td>218114.0</td>
      <td>13848364.0</td>
      <td>290347.0</td>
      <td>8600132.0</td>
      <td>5248232.0</td>
    </tr>
    <tr>
      <th>114</th>
      <td>2018년 03월</td>
      <td>중국</td>
      <td>232396.0</td>
      <td>13576667.0</td>
      <td>267249.0</td>
      <td>8412516.0</td>
      <td>5164151.0</td>
    </tr>
    <tr>
      <th>116</th>
      <td>2018년 03월</td>
      <td>일본</td>
      <td>80142.0</td>
      <td>2603450.0</td>
      <td>159601.0</td>
      <td>5226141.0</td>
      <td>-2622691.0</td>
    </tr>
    <tr>
      <th>120</th>
      <td>2018년 05월</td>
      <td>중국</td>
      <td>214145.0</td>
      <td>13851900.0</td>
      <td>307183.0</td>
      <td>9279720.0</td>
      <td>4572180.0</td>
    </tr>
    <tr>
      <th>123</th>
      <td>2018년 06월</td>
      <td>중국</td>
      <td>257130.0</td>
      <td>13814241.0</td>
      <td>279023.0</td>
      <td>8713018.0</td>
      <td>5101223.0</td>
    </tr>
    <tr>
      <th>126</th>
      <td>2018년 07월</td>
      <td>중국</td>
      <td>181772.0</td>
      <td>13721233.0</td>
      <td>293164.0</td>
      <td>8869278.0</td>
      <td>4851955.0</td>
    </tr>
    <tr>
      <th>129</th>
      <td>2018년 08월</td>
      <td>중국</td>
      <td>199010.0</td>
      <td>14401521.0</td>
      <td>280033.0</td>
      <td>8525532.0</td>
      <td>5875989.0</td>
    </tr>
    <tr>
      <th>132</th>
      <td>2018년 09월</td>
      <td>중국</td>
      <td>171328.0</td>
      <td>14590529.0</td>
      <td>280337.0</td>
      <td>7889890.0</td>
      <td>6700639.0</td>
    </tr>
    <tr>
      <th>135</th>
      <td>2018년 10월</td>
      <td>중국</td>
      <td>169809.0</td>
      <td>14767041.0</td>
      <td>319876.0</td>
      <td>9963108.0</td>
      <td>4803932.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
trade.loc[outlier(trade, '무역수지', 2)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>129</th>
      <td>2018년 08월</td>
      <td>중국</td>
      <td>199010.0</td>
      <td>14401521.0</td>
      <td>280033.0</td>
      <td>8525532.0</td>
      <td>5875989.0</td>
    </tr>
    <tr>
      <th>132</th>
      <td>2018년 09월</td>
      <td>중국</td>
      <td>171328.0</td>
      <td>14590529.0</td>
      <td>280337.0</td>
      <td>7889890.0</td>
      <td>6700639.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
trade.loc[outlier(trade, '무역수지', 3)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



무역수지의 이상치를 확인하는데 기준 되는 값이 클수록 이상치가 적어지는 것을 확인할 수 있습니다.   
이제 not_outlier라는 함수를 통해 무역수지가 이상치 값이 아닌 데이터만 추출하도록 하겠습니다.


```python
def not_outlier(df, col, z):
    return df[abs(df[col] - np.mean(df[col]))/np.std(df[col]) <= z].index
```


```python
trade.loc[not_outlier(trade, '무역수지', 1.5)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015년 01월</td>
      <td>중국</td>
      <td>116932.0</td>
      <td>12083947.0</td>
      <td>334522.0</td>
      <td>8143271.0</td>
      <td>3940676.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015년 01월</td>
      <td>미국</td>
      <td>65888.0</td>
      <td>5561545.0</td>
      <td>509564.0</td>
      <td>3625062.0</td>
      <td>1936484.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015년 01월</td>
      <td>일본</td>
      <td>54017.0</td>
      <td>2251307.0</td>
      <td>82480.0</td>
      <td>3827247.0</td>
      <td>-1575940.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015년 02월</td>
      <td>중국</td>
      <td>86228.0</td>
      <td>9927642.0</td>
      <td>209100.0</td>
      <td>6980874.0</td>
      <td>2946768.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015년 02월</td>
      <td>미국</td>
      <td>60225.0</td>
      <td>5021264.0</td>
      <td>428678.0</td>
      <td>2998216.0</td>
      <td>2023048.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>191</th>
      <td>2020년 04월</td>
      <td>미국</td>
      <td>105360.0</td>
      <td>5946782.0</td>
      <td>1141118.0</td>
      <td>5038739.0</td>
      <td>908043.0</td>
    </tr>
    <tr>
      <th>192</th>
      <td>2020년 04월</td>
      <td>일본</td>
      <td>134118.0</td>
      <td>1989323.0</td>
      <td>141207.0</td>
      <td>3989562.0</td>
      <td>-2000239.0</td>
    </tr>
    <tr>
      <th>193</th>
      <td>2020년 05월</td>
      <td>중국</td>
      <td>185320.0</td>
      <td>10746069.0</td>
      <td>349007.0</td>
      <td>8989920.0</td>
      <td>1756149.0</td>
    </tr>
    <tr>
      <th>194</th>
      <td>2020년 05월</td>
      <td>미국</td>
      <td>126598.0</td>
      <td>4600726.0</td>
      <td>1157163.0</td>
      <td>4286873.0</td>
      <td>313853.0</td>
    </tr>
    <tr>
      <th>195</th>
      <td>2020년 05월</td>
      <td>일본</td>
      <td>166568.0</td>
      <td>1798128.0</td>
      <td>133763.0</td>
      <td>3102734.0</td>
      <td>-1304606.0</td>
    </tr>
  </tbody>
</table>
<p>179 rows × 7 columns</p>
</div>



### IQR method
***
하지만 이상치를 찾는 방법에는 위에 설명한 z-score 방법만 있는 것은 아닙니다. 그리고 z-score 방법은 몇 가지 뚜렷한 한계점을 가지고 있습니다.

z-score방법의 대안으로 사분위 범위수 IQR(Interquartile range)로 이상치를 알아내는 방법을 알아보겠습니다. 

이해를 돕기 위해 아웃라이어가 포함된 임의의 데이터를 만들어보겠습니다.


```python
import numpy as np
np.random.seed(2020)
data = np.random.randn(100)  # 평균 0, 표준편차 1의 분포에서 100개의 숫자를 샘플링한 데이터 생성
data = np.concatenate((data, np.array([8, 10, -3, -5])))      # [8, 10, -3, -5])를 데이터 뒤에 추가함
data
```




    array([-1.76884571,  0.07555227, -1.1306297 , -0.65143017, -0.89311563,
           -1.27410098, -0.06115443,  0.06451384,  0.41011295, -0.57288249,
           -0.80133362,  1.31203519,  1.27469887, -1.2143576 ,  0.31371941,
           -1.44482142, -0.3689613 , -0.76922658,  0.3926161 ,  0.05729383,
            2.08997884,  0.04197131, -0.04834072, -0.51315392, -0.08458928,
           -1.21545008, -1.41293073, -1.48691055,  0.38222486,  0.937673  ,
            1.77267804,  0.87882801,  0.33171912, -0.30603567,  1.24026615,
           -0.21562684,  0.15592948,  0.09805553,  0.83209585,  2.04520542,
           -0.31681392, -1.31283291, -1.75445746,  0.10209408, -1.36150208,
            0.48178488, -0.20832874, -0.09186351,  0.70268816,  0.10365506,
            0.62123638,  0.95411497,  2.03781352, -0.48445122,  0.2071549 ,
            1.64424216, -0.4882074 , -0.01782826,  0.46891556,  0.27987266,
           -0.64664972, -0.54406002, -0.16008985,  0.03781172,  1.03383296,
           -1.23096117, -1.24673665,  0.29572055,  2.1409624 , -0.92020227,
           -0.06000238,  0.27978391, -1.53126966, -0.30293101, -0.14601413,
            0.27746159, -0.13952066,  0.69515966, -0.11338746, -1.233267  ,
           -0.79614131, -0.46739138,  0.65890607, -0.41063115,  0.17344356,
            0.28946174,  1.03451736,  1.22661712,  1.71998252,  0.40806834,
            0.32256894,  1.04722748, -1.8196003 , -0.42582157,  0.12454883,
            2.31256634, -0.96557586, -0.34627486,  0.96668378, -0.92550192,
            8.        , 10.        , -3.        , -5.        ])




```python
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.boxplot(data)
plt.show()
```


    
![png](output_49_0.png)
    


박스 플롯에서 박스를 벗어난 점들이 보이시나요?

우리는 사분위 범위수 IQR(Interquartile range)을 이용하여 이상치를 찾아낼 수 있습니다.

$$ IQR = Q_3 - Q_1 $$

즉, IQR은 제 3사분위수에서 제 1사분위 값을 뺀 값으로 데이터의 중간 50%의 범위라고 생각하시면 됩니다. $ Q_1 - 1.5 * IQR$보다 왼쪽에 있거나, $Q_3 + 1.5 * IQR$보다 오른쪽에 있는 경우 우리는 이상치라고 판단합니다.

아래 그림을 보면 이 식의 의미가 더 와닿을 겁니다.

![스크린샷 2023-01-27 오후 7.49.22.png](attachment:1257d1cc-4062-4196-aaa6-e3470b194690.png)

IQR을 구하기 위해 우선 제 1사분위수와 제 3사분위수를 구합니다.


```python
Q3, Q1 = np.percentile(data, [75,25])
IQR = Q3 - Q1
IQR
```




    1.1644925829790964



IQR과 제 1사분위수, 제 3사분위수를 이용하여 이상치를 확인할 수 있습니다.


```python
data[(Q1-1.5*IQR > data)|(Q3+1.5*IQR < data)]
```




    array([ 2.31256634,  8.        , 10.        , -3.        , -5.        ])



위에서 z-score 방법과 IQR 방법에 대해서 알아보았습니다.  
무역수지를 기준으로 이상치를 찾는 실습을 해보도록 하겠습니다.


```python
def outlier2(df, col):
    q1 = df[col].quantile(0.25)
    q3 = df[col].quantile(0.75)
    iqr = q3 - q1
    return df[(df[col] < q1-1.5*iqr)|(df[col] > q3+1.5*iqr)]

outlier2(trade, '무역수지')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



# 정규화
trade 데이터를 보면 수입건수, 수출건수와 수입금액, 수출금액, 무역수지는 단위가 다르다는 것을 알 수 있습니다. 

이처럼 컬럼마다 스케일이 크게 차이가 나는 데이터를 입력하면 머신러닝 모델 학습에 문제가 발생할 수 있습니다. 예를 들어 데이터의 범위가 0\~1 사이인 컬럼 A와 1000~10000사이인 컬럼 B가 있다고 생각해 봅시다. 이런 데이터를 클러스터링(군집화)한다고 가정해 봅시다. 데이터 간의 거리를 잴 때, 범위가 큰 컬럼 B의 값에만 영향을 크게 받을 것입니다.  
그래서 일반적으로 컬럼 간에 범위가 크게 다를 경우 전처리 과정에서 데이터를 정규화합니다.

- 정규화(Normalization) : 값의 범위를 0~1 사이로 변경
    - sklearn에서 MinMaxScaler사용
- 표준화(Standardization) : 평균-0, 분산-1로 변경
    - sklearn에서 StandardScaler사용
    
정규화 기법이 데이터의 분포를 어떻게 바꾸는지 살펴봅시다.  
우선 임의의 데이터를 생성하고, 각각의 기법으로 데이터를 정규화시켜줍니다.


```python
# 정규분포를 따라 랜덤하게 데이터 x를 생성합니다. 
x = pd.DataFrame({'A': np.random.randn(100)*4+4,
                 'B': np.random.randn(100)-1})
x
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>6.205792</td>
      <td>-1.485248</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-0.604047</td>
      <td>-0.727779</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3.018785</td>
      <td>-0.517099</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.323325</td>
      <td>-0.414949</td>
    </tr>
    <tr>
      <th>4</th>
      <td>6.167679</td>
      <td>-0.582630</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>95</th>
      <td>5.062917</td>
      <td>-1.122239</td>
    </tr>
    <tr>
      <th>96</th>
      <td>-0.166839</td>
      <td>-2.487547</td>
    </tr>
    <tr>
      <th>97</th>
      <td>-4.230178</td>
      <td>0.589513</td>
    </tr>
    <tr>
      <th>98</th>
      <td>-0.562115</td>
      <td>0.779614</td>
    </tr>
    <tr>
      <th>99</th>
      <td>5.984528</td>
      <td>-1.724450</td>
    </tr>
  </tbody>
</table>
<p>100 rows × 2 columns</p>
</div>




```python
# 데이터 x를 Standardization 기법으로 정규화합니다. 
x_standardization = (x - x.mean())/x.std()
x_standardization
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.559307</td>
      <td>-0.314995</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.132240</td>
      <td>0.407499</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.232338</td>
      <td>0.608450</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.156691</td>
      <td>0.705884</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.549839</td>
      <td>0.545945</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>95</th>
      <td>0.275419</td>
      <td>0.031252</td>
    </tr>
    <tr>
      <th>96</th>
      <td>-1.023639</td>
      <td>-1.271014</td>
    </tr>
    <tr>
      <th>97</th>
      <td>-2.032961</td>
      <td>1.663966</td>
    </tr>
    <tr>
      <th>98</th>
      <td>-1.121824</td>
      <td>1.845290</td>
    </tr>
    <tr>
      <th>99</th>
      <td>0.504345</td>
      <td>-0.543153</td>
    </tr>
  </tbody>
</table>
<p>100 rows × 2 columns</p>
</div>




```python
# 데이터 x를 min-max scaling 기법으로 정규화합니다. 
x_min_max = (x-x.min())/(x.max()-x.min())
x_min_max
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.607216</td>
      <td>0.426240</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.267692</td>
      <td>0.571821</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.448318</td>
      <td>0.612312</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.463502</td>
      <td>0.631944</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.605316</td>
      <td>0.599717</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>95</th>
      <td>0.550235</td>
      <td>0.496008</td>
    </tr>
    <tr>
      <th>96</th>
      <td>0.289490</td>
      <td>0.233606</td>
    </tr>
    <tr>
      <th>97</th>
      <td>0.086901</td>
      <td>0.824995</td>
    </tr>
    <tr>
      <th>98</th>
      <td>0.269782</td>
      <td>0.861531</td>
    </tr>
    <tr>
      <th>99</th>
      <td>0.596184</td>
      <td>0.380268</td>
    </tr>
  </tbody>
</table>
<p>100 rows × 2 columns</p>
</div>



다음 이미지는 데이터를 Standardization 기법으로 정규화를 했을 때 분포가 어떻게 바뀌는지 보여줍니다. 즉, 각 컬럼의 평균은 0으로, 분산은 1로 데이터를 바꿔줍니다.


```python
fig, axs = plt.subplots(1,2, figsize=(12, 4),
                        gridspec_kw={'width_ratios': [2, 1]})

axs[0].scatter(x['A'], x['B'])
axs[0].set_xlim(-5, 15)
axs[0].set_ylim(-5, 5)
axs[0].axvline(c='grey', lw=1)
axs[0].axhline(c='grey', lw=1)
axs[0].set_title('Original Data')

axs[1].scatter(x_standardization['A'], x_standardization['B'])
axs[1].set_xlim(-5, 5)
axs[1].set_ylim(-5, 5)
axs[1].axvline(c='grey', lw=1)
axs[1].axhline(c='grey', lw=1)
axs[1].set_title('Data after standardization')

plt.show()
```


    
![png](output_61_0.png)
    


다음 이미지는 동일한 데이터를 min-max scaling 기법으로 정규화를 했을 때 분포가 어떻게 바뀌는지 보여줍니다. 즉, 각 컬럼의 최솟값은 0, 최댓값은 1로 바꿔줍니다.


```python
fig, axs = plt.subplots(1,2, figsize=(12, 4),
                        gridspec_kw={'width_ratios': [2, 1]})

axs[0].scatter(x['A'], x['B'])
axs[0].set_xlim(-5, 15)
axs[0].set_ylim(-5, 5)
axs[0].axvline(c='grey', lw=1)
axs[0].axhline(c='grey', lw=1)
axs[0].set_title('Original Data')

axs[1].scatter(x_min_max['A'], x_min_max['B'])
axs[1].set_xlim(-5, 5)
axs[1].set_ylim(-5, 5)
axs[1].axvline(c='grey', lw=1)
axs[1].axhline(c='grey', lw=1)
axs[1].set_title('Data after min-max scaling')

plt.show()
```


    
![png](output_63_0.png)
    


그럼 우리가 가진 trade 데이터를 살펴봅시다.
### Standardization
***
우선 정규화를 시켜야 할 수치형 컬럼들을 cols 변수에 담은 후, 데이터에서 평균을 빼고, 표준편차로 나눠주도록 합니다.


```python
# trade 데이터를 Standardization 기법으로 정규화합니다. 
cols = ['수출건수', '수출금액', '수입건수', '수입금액', '무역수지']
trade_Standardization= (trade[cols]-trade[cols].mean())/trade[cols].std()
trade_Standardization.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-0.007488</td>
      <td>1.398931</td>
      <td>-0.163593</td>
      <td>1.283660</td>
      <td>1.256342</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-0.689278</td>
      <td>-0.252848</td>
      <td>0.412529</td>
      <td>-0.964444</td>
      <td>0.401088</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.847838</td>
      <td>-1.091156</td>
      <td>-0.993148</td>
      <td>-0.863844</td>
      <td>-1.097779</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.417598</td>
      <td>0.852853</td>
      <td>-0.576399</td>
      <td>0.705292</td>
      <td>0.832209</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-0.764918</td>
      <td>-0.389673</td>
      <td>0.146306</td>
      <td>-1.276341</td>
      <td>0.438027</td>
    </tr>
  </tbody>
</table>
</div>



standardization 방법으로 정규화시킨 trade_Standardization을 확인해 보겠습니다. 각 컬럼의 평균들을 보면 거의 0에 가깝고, 표준편차는 1에 가까운 것을 확인하실 수 있습니다.


```python
trade_Standardization.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1.950000e+02</td>
      <td>1.950000e+02</td>
      <td>1.950000e+02</td>
      <td>1.950000e+02</td>
      <td>1.950000e+02</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>-1.093143e-16</td>
      <td>6.832142e-17</td>
      <td>1.821904e-17</td>
      <td>-5.465713e-17</td>
      <td>2.277381e-17</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1.000000e+00</td>
      <td>1.000000e+00</td>
      <td>1.000000e+00</td>
      <td>1.000000e+00</td>
      <td>1.000000e+00</td>
    </tr>
    <tr>
      <th>min</th>
      <td>-9.194976e-01</td>
      <td>-1.231761e+00</td>
      <td>-9.984408e-01</td>
      <td>-1.276341e+00</td>
      <td>-1.603764e+00</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>-5.937426e-01</td>
      <td>-1.041338e+00</td>
      <td>-7.673625e-01</td>
      <td>-7.911669e-01</td>
      <td>-1.116765e+00</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>-4.373265e-01</td>
      <td>-1.564700e-01</td>
      <td>-3.429346e-01</td>
      <td>-4.137392e-01</td>
      <td>1.426824e-01</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>4.420459e-01</td>
      <td>1.037200e+00</td>
      <td>3.927781e-01</td>
      <td>8.827841e-01</td>
      <td>7.461637e-01</td>
    </tr>
    <tr>
      <th>max</th>
      <td>5.486317e+00</td>
      <td>2.078416e+00</td>
      <td>3.239068e+00</td>
      <td>2.376092e+00</td>
      <td>2.434109e+00</td>
    </tr>
  </tbody>
</table>
</div>



### Min-Max Scaling
***
데이터에서 최솟값을 빼주고, '최댓값-최솟값'으로 나눠줍니다.


```python
# trade 데이터를 min-max scaling 기법으로 정규화합니다. 
trade[cols] = (trade[cols]-trade[cols].min())/(trade[cols].max()-trade[cols].min())
trade.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015년 01월</td>
      <td>중국</td>
      <td>0.142372</td>
      <td>0.794728</td>
      <td>0.197014</td>
      <td>0.700903</td>
      <td>0.708320</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015년 01월</td>
      <td>미국</td>
      <td>0.035939</td>
      <td>0.295728</td>
      <td>0.332972</td>
      <td>0.085394</td>
      <td>0.496512</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015년 01월</td>
      <td>일본</td>
      <td>0.011187</td>
      <td>0.042477</td>
      <td>0.001249</td>
      <td>0.112938</td>
      <td>0.125310</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015년 02월</td>
      <td>중국</td>
      <td>0.078351</td>
      <td>0.629759</td>
      <td>0.099597</td>
      <td>0.542551</td>
      <td>0.603281</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015년 02월</td>
      <td>미국</td>
      <td>0.024131</td>
      <td>0.254394</td>
      <td>0.270146</td>
      <td>0.000000</td>
      <td>0.505660</td>
    </tr>
  </tbody>
</table>
</div>



Min-Max Scaling 방법으로 정규화시킨 후, 각 컬럼의 최솟값(min)은 0이고, 최댓값(max)은 1임을 확인할 수 있습니다.

우리는 실제로 해당 값에 대한 분포를 정확하게 모르기 때문에 Standardization보다 Min-Max Scaling을 사용해 정규화하겠습니다.


```python
trade.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>195.000000</td>
      <td>195.000000</td>
      <td>195.000000</td>
      <td>195.000000</td>
      <td>195.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.143541</td>
      <td>0.372113</td>
      <td>0.235620</td>
      <td>0.349450</td>
      <td>0.397180</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.156108</td>
      <td>0.302099</td>
      <td>0.235988</td>
      <td>0.273790</td>
      <td>0.247655</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.050853</td>
      <td>0.057527</td>
      <td>0.054532</td>
      <td>0.132836</td>
      <td>0.120608</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.075271</td>
      <td>0.324844</td>
      <td>0.154691</td>
      <td>0.236172</td>
      <td>0.432516</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.212548</td>
      <td>0.685450</td>
      <td>0.328311</td>
      <td>0.591147</td>
      <td>0.581972</td>
    </tr>
    <tr>
      <th>max</th>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>1.000000</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div>



주의!!

train 데이터와 test 데이터가 나눠져 있는 경우 train 데이터를 정규화시켰던 기준 그대로 test 데이터도 정규화 시켜줘야 합니다.


```python
train = pd.DataFrame([[10, -10], [30, 10], [50, 0]])
test = pd.DataFrame([[0, 1], [10, 10]])
```

아래 코드를 자세히 보시기 바랍니다!!


```python
train_min = train.min()
train_max = train.max()

train_min_max = (train - train_min)/(train_max - train_min)
test_min_max =  (test - train_min)/(train_max - train_min)    # test를 min-max scaling할 때도 train 정규화 기준으로 수행
```


```python
train_min_max
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.5</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>0.5</td>
    </tr>
  </tbody>
</table>
</div>




```python
test_min_max
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-0.25</td>
      <td>0.55</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.00</td>
      <td>1.00</td>
    </tr>
  </tbody>
</table>
</div>



scikit-learn의 StandardScaler, MinMaxScaler를 사용하는 방법도 있습니다.


```python
from sklearn.preprocessing import MinMaxScaler
train = [[10, -10], [30, 10], [50, 0]]
test = [[0, 1]]
scaler = MinMaxScaler()
```


```python
scaler.fit_transform(train)
```




    array([[0. , 0. ],
           [0.5, 1. ],
           [1. , 0.5]])




```python
scaler.transform(test)
```




    array([[-0.25,  0.55]])



- [Normalizing Inputs](https://youtu.be/FDCfw-YqWTE)

위에서 언급하지 않았지만, 로그 변환 등의 기법도 정규화화 함께 사용하면 도움이 될 수 있다는 것도 기억해 주세요!

# 10-6. 원-핫 인코딩(One-Hot Encoding)
이제 범주형 데이터인 국가명 컬럼을 다뤄보도록 하겠습니다.

머신러닝이나 딥러닝 프레임워크에서 범주형을 지원하지 않는 경우 원-핫 인코딩을 해야 합니다.

원-핫 인코딩이란 무엇인가요?

원-핫 인코딩이란 카테고리별 이진 특성을 만들어 해당하는 특성만 1, 나머지는 0으로 만드는 방법입니다. 그럼, pandas로 국가명 컬럼을 원-핫 인코딩을 해보겠습니다.

pandas에서 get_dummies 함수를 통해 손쉽게 원-핫 인코딩을 할 수 있습니다.


```python
#trade 데이터의 국가명 컬럼 원본
print(trade['국가명'].head())  

# get_dummies를 통해 국가명 원-핫 인코딩
country = pd.get_dummies(trade['국가명'])
country.head()
```

    0    중국
    1    미국
    2    일본
    3    중국
    4    미국
    Name: 국가명, dtype: object





<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>미국</th>
      <th>일본</th>
      <th>중국</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



pd.concat 함수로 데이터프레임 trade와 country를 합쳐줍니다.


```python
trade = pd.concat([trade, country], axis=1)
trade.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>국가명</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
      <th>미국</th>
      <th>일본</th>
      <th>중국</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015년 01월</td>
      <td>중국</td>
      <td>0.142372</td>
      <td>0.794728</td>
      <td>0.197014</td>
      <td>0.700903</td>
      <td>0.708320</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015년 01월</td>
      <td>미국</td>
      <td>0.035939</td>
      <td>0.295728</td>
      <td>0.332972</td>
      <td>0.085394</td>
      <td>0.496512</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015년 01월</td>
      <td>일본</td>
      <td>0.011187</td>
      <td>0.042477</td>
      <td>0.001249</td>
      <td>0.112938</td>
      <td>0.125310</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015년 02월</td>
      <td>중국</td>
      <td>0.078351</td>
      <td>0.629759</td>
      <td>0.099597</td>
      <td>0.542551</td>
      <td>0.603281</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015년 02월</td>
      <td>미국</td>
      <td>0.024131</td>
      <td>0.254394</td>
      <td>0.270146</td>
      <td>0.000000</td>
      <td>0.505660</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



이제 필요 없어진 국가명 컬럼을 삭제해 주고 나면 trade는 우리가 원하는 데이터프레임이 됩니다.


```python
trade.drop(['국가명'], axis=1, inplace=True)
trade.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>기간</th>
      <th>수출건수</th>
      <th>수출금액</th>
      <th>수입건수</th>
      <th>수입금액</th>
      <th>무역수지</th>
      <th>미국</th>
      <th>일본</th>
      <th>중국</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015년 01월</td>
      <td>0.142372</td>
      <td>0.794728</td>
      <td>0.197014</td>
      <td>0.700903</td>
      <td>0.708320</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015년 01월</td>
      <td>0.035939</td>
      <td>0.295728</td>
      <td>0.332972</td>
      <td>0.085394</td>
      <td>0.496512</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015년 01월</td>
      <td>0.011187</td>
      <td>0.042477</td>
      <td>0.001249</td>
      <td>0.112938</td>
      <td>0.125310</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015년 02월</td>
      <td>0.078351</td>
      <td>0.629759</td>
      <td>0.099597</td>
      <td>0.542551</td>
      <td>0.603281</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015년 02월</td>
      <td>0.024131</td>
      <td>0.254394</td>
      <td>0.270146</td>
      <td>0.000000</td>
      <td>0.505660</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



# 10-7. 구간화(Binning)
지금까지 trade 데이터를 다루면서 다양 전처리 기법을 배웠습니다. 이제 다른 전처리 기법을 배워보도록 하겠습니다.

salary에 소득 데이터가 있다고 합시다.


```python
salary = pd.Series([4300, 8370, 1750, 3830, 1840, 4220, 3020, 2290, 4740, 4600, 
                    2860, 3400, 4800, 4470, 2440, 4530, 4850, 4850, 4760, 4500, 
                    4640, 3000, 1880, 4880, 2240, 4750, 2750, 2810, 3100, 4290, 
                    1540, 2870, 1780, 4670, 4150, 2010, 3580, 1610, 2930, 4300, 
                    2740, 1680, 3490, 4350, 1680, 6420, 8740, 8980, 9080, 3990, 
                    4960, 3700, 9600, 9330, 5600, 4100, 1770, 8280, 3120, 1950, 
                    4210, 2020, 3820, 3170, 6330, 2570, 6940, 8610, 5060, 6370,
                    9080, 3760, 8060, 2500, 4660, 1770, 9220, 3380, 2490, 3450, 
                    1960, 7210, 5810, 9450, 8910, 3470, 7350, 8410, 7520, 9610, 
                    5150, 2630, 5610, 2750, 7050, 3350, 9450, 7140, 4170, 3090])
```

이 데이터를 구간별로 나누고자 합니다. 이러한 기법을 구간화(Data binning 혹은 bucketing)이라고 부릅니다.

아래 히스토그램과 같이 연속적인 데이터를 구간을 나눠 분석할 때 사용하는 방법입니다.


```python
salary.hist()
```




    <AxesSubplot: >




    
![png](output_91_1.png)
    


pandas의 cut과 qcut을 이용해 수치형 데이터를 범주형 데이터로 변형시키도록 하겠습니다.

cut을 사용하기 위해 우선 구간을 정해줍니다.


```python
bins = [0, 2000, 4000, 6000, 8000, 10000]
```

cut 함수에 데이터와 구간을 입력하면 데이터를 구간별로 나눠줍니다.


```python
ctg = pd.cut(salary, bins=bins)
ctg
```




    0      (4000, 6000]
    1     (8000, 10000]
    2         (0, 2000]
    3      (2000, 4000]
    4         (0, 2000]
              ...      
    95     (2000, 4000]
    96    (8000, 10000]
    97     (6000, 8000]
    98     (4000, 6000]
    99     (2000, 4000]
    Length: 100, dtype: category
    Categories (5, interval[int64, right]): [(0, 2000] < (2000, 4000] < (4000, 6000] < (6000, 8000] < (8000, 10000]]



salary[0]은 4300으로 4000에서 6000 사이에 포함되었다는 것을 확인할 수 있습니다.


```python
print('salary[0]:', salary[0])
print('salary[0]가 속한 카테고리:', ctg[0])
```

    salary[0]: 4300
    salary[0]가 속한 카테고리: (4000, 6000]


구간별로 값이 몇 개가 속해 있는지 value_counts()로 확인해 봅시다.


```python
ctg.value_counts().sort_index() # index 오름차순 정렬
```




    (0, 2000]        12
    (2000, 4000]     34
    (4000, 6000]     29
    (6000, 8000]      9
    (8000, 10000]    16
    dtype: int64



이렇게 특정 구간을 지정해 줘도 되고, 구간의 개수를 지정해 줄 수도 있습니다. bins 옵션에 정수를 입력하면 데이터의 최솟값에서 최댓값을 균등하게 bins 개수만큼 나눠줍니다.


```python
ctg = pd.cut(salary, bins=6)
ctg
```




    0      (4230.0, 5575.0]
    1      (8265.0, 9610.0]
    2     (1531.93, 2885.0]
    3      (2885.0, 4230.0]
    4     (1531.93, 2885.0]
                ...        
    95     (2885.0, 4230.0]
    96     (8265.0, 9610.0]
    97     (6920.0, 8265.0]
    98     (2885.0, 4230.0]
    99     (2885.0, 4230.0]
    Length: 100, dtype: category
    Categories (6, interval[float64, right]): [(1531.93, 2885.0] < (2885.0, 4230.0] < (4230.0, 5575.0] < (5575.0, 6920.0] < (6920.0, 8265.0] < (8265.0, 9610.0]]




```python
ctg.value_counts().sort_index()
```




    (1531.93, 2885.0]    27
    (2885.0, 4230.0]     24
    (4230.0, 5575.0]     21
    (5575.0, 6920.0]      6
    (6920.0, 8265.0]      7
    (8265.0, 9610.0]     15
    dtype: int64



qcut은 구간을 일정하게 나누는 것이 아니라 데이터의 분포를 비슷한 크기의 그룹으로 나눠줍니다.


```python
ctg = pd.qcut(salary, q=5)
ctg
```




    0       (3544.0, 4648.0]
    1       (7068.0, 9610.0]
    2     (1539.999, 2618.0]
    3       (3544.0, 4648.0]
    4     (1539.999, 2618.0]
                 ...        
    95      (2618.0, 3544.0]
    96      (7068.0, 9610.0]
    97      (7068.0, 9610.0]
    98      (3544.0, 4648.0]
    99      (2618.0, 3544.0]
    Length: 100, dtype: category
    Categories (5, interval[float64, right]): [(1539.999, 2618.0] < (2618.0, 3544.0] < (3544.0, 4648.0] < (4648.0, 7068.0] < (7068.0, 9610.0]]




```python
print(ctg.value_counts().sort_index())
```

    (1539.999, 2618.0]    20
    (2618.0, 3544.0]      20
    (3544.0, 4648.0]      20
    (4648.0, 7068.0]      20
    (7068.0, 9610.0]      20
    dtype: int64


# 긴 글 읽어주셔서 감사합니다!! 수고하셨습니다!
